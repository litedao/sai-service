#! /usr/bin/env node

const mongoose = require('./schema').mongoose;
const settings = require('./settings');
const Web3 = require('web3');
var Queue = require('sync-queue');

const web3 = new Web3();
let port = 8545;
process.argv.forEach(function (v, i) {
  if (v === '--port' && typeof process.argv[i + 1] !== 'undefined') {
    port = process.argv[i + 1];
  }
});
web3.setProvider(new Web3.providers.HttpProvider(`http://localhost:${port}`));

console.log(`MongoDB syncing from http://localhost:${port}`);

const topAbi = require('./abi/top').abi;
const tubAbi = require('./abi/tub').abi;
const tapAbi = require('./abi/tap').abi;
const jarAbi = require('./abi/jar').abi;
const tipAbi = require('./abi/tip').abi;
const medAbi = require('./abi/medianizer').abi;

web3.eth.getBlock(0, (e, res) => {
  let network = false;
  if (!e) {
    switch (res.hash) {
      case '0xa3c565fc15c7478862d50ccd6561e3c06b24cc509bf388941c25ea985ce32cb9':
        network = 'kovan';
        break;
      case '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3':
        network = 'main';
        break;
      default:
        network = 'private';
    }
    console.log(`${network} network detected`)
    mongoose.connect(`mongodb://localhost/sai-service-${network}`, { useMongoClient: true }, (e) => {
      if (!e) {
        init(network);
      }
    });
  }
 });

const methodSig = (method) => {
  return web3.sha3(method).substring(0, 10)
}

const getAddress = (object, name) => {
  const p = new Promise((resolve, reject) => {
    object[name].call((e, r) => {
      if (!e) {
        resolve(r);
      } else {
        reject(e);
      }
    });
  });
  return p;
}

const init = (network) => {
  const top = web3.eth.contract(topAbi).at(settings.chain[network].top);
  const promises = [getAddress(top, 'tub'), getAddress(top, 'tap')];
  Promise.all(promises).then((r) => {
    if (r[0] && r[1] && web3.isAddress(r[0]) && web3.isAddress(r[1])) {
      const tub = web3.eth.contract(tubAbi).at(r[0]);
      const tap = web3.eth.contract(tapAbi).at(r[1]);
      const promises2 = [getAddress(tub, 'jar'), getAddress(tub, 'tip')];
      Promise.all(promises2).then((r2) => {
        if (r2[0] && r2[1] && web3.isAddress(r2[0]) && web3.isAddress(r2[1])) {
          const jar = web3.eth.contract(jarAbi).at(r2[0]);
          const tip = web3.eth.contract(tipAbi).at(r2[1]);
          const promise = getAddress(jar, 'pip');
          Promise.resolve(promise).then((r3) => {
            if (r3 && web3.isAddress(r3)) {
              const med = web3.eth.contract(medAbi).at(r3);
              executeSync(tub, tap, jar, tip, med);
            }
          });
        }
      });
    }
  });
}

const executeSync = (tub, tap, jar, tip, med) => {
  const Var = mongoose.model('Var');
  const Way = mongoose.model('Way');
  const Mat = mongoose.model('Mat');
  const Per = mongoose.model('Per');
  const Pip = mongoose.model('Pip');
  const Cup = mongoose.model('Cup');

  Way.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      tip.LogNote({ sig: methodSig('coax(uint128)') }, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Way.collection.insert({ value: web3.toBigNumber(r2.args.foo).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
            }
          });
        }
      });
    }
  });

  Mat.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      tub.LogNote({ sig: methodSig('cuff(uint128)') }, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Mat.collection.insert({ value: web3.toBigNumber(r2.args.foo).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
              Var.collection.update({ name: 'mat' },
                                  {
                                    name: 'mat',
                                    value: web3.toBigNumber(r2.args.foo).div(1000000000).toNumber(),
                                  },
                                  { upsert: true });
            }
          });
        }
      });
    }
  });

  Per.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      tap.LogNote({ sig: [methodSig('boom(uint128)'), methodSig('bust(uint128)')] }, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              jar.per(r2.blockNumber, (e4, r4) => {
                if (!e4) {
                  Per.collection.insert({ value: web3.toBigNumber(r4).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
                  Var.collection.update({ name: 'per' },
                                  {
                                    name: 'per',
                                    value: web3.toBigNumber(r4).div(1000000000).toNumber(),
                                  },
                                  { upsert: true });
                }
              });
            }
          });
        }
      });
    }
  });

  Pip.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      med.LogValue({}, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Pip.collection.insert({ value: r2.args.val !== '0x' ? web3.toBigNumber(r2.args.val).toNumber() : null, last_block: r2.blockNumber, timestamp: r3.timestamp });
              Var.collection.update({ name: 'pip' },
                                {
                                  name: 'pip',
                                  value: web3.toBigNumber(r2.args.val).toNumber(),
                                },
                                { upsert: true });
            }
          });
        }
      });
    }
  });

  setInterval(() => {
    tub.chi.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'chi' },
                                {
                                  name: 'chi',
                                  value: r.div(1000000000).toNumber(),
                                },
                                { upsert: true });
      }
    });

    tip.par.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'par' },
                                  {
                                    name: 'par',
                                    value: r.toNumber(),
                                  },
                                  { upsert: true });
      }
    });
  }, 5000);

  var cupsQueue = new Queue();
  Cup.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    web3.eth.filter({ fromBlock: (r.length === 0 ? 0 : r[0].last_block), address: tub.address }, (e2, r2) => {
      if (!e2) {
        if (r2.topics[0] === web3.sha3('LogNewCup(address,bytes32)')) {
          cupsQueue.place(() => Cup.collection.update({ cupi: web3.toBigNumber(r2.data).toNumber() },
                                {
                                  cupi: web3.toBigNumber(r2.data).toNumber(),
                                  lad: '0x' + r2.topics[1].substring(26),
                                  art: 0,
                                  ink: 0,
                                  closed: false,
                                  last_block: r2.blockNumber
                                },
                                { upsert: true }, () => cupsQueue.next()));
        } else if (r2.topics[0] === methodSig('shut(bytes32)') + '00000000000000000000000000000000000000000000000000000000') {
          cupsQueue.place(() => Cup.collection.update({ cupi: web3.toBigNumber(r2.topics[2]).toNumber() },
                                {
                                  $set:
                                        {
                                          art: 0,
                                          ink: 0,
                                          closed: true,
                                          last_block: r2.blockNumber
                                        }
                                }, {}, () => cupsQueue.next()));
        } else if (r2.topics[0] === methodSig('give(bytes32,address)') + '00000000000000000000000000000000000000000000000000000000') {
          cupsQueue.place(() => Cup.collection.update({ cupi: web3.toBigNumber(r2.topics[2]).toNumber() },
                                { $set:
                                        {
                                          lad: '0x' + r2.topics[3].substring(26),
                                          last_block: r2.blockNumber
                                        }
                                }, {}, () => cupsQueue.next()));
        } else if (r2.topics[0] === methodSig('lock(bytes32,uint128)') + '00000000000000000000000000000000000000000000000000000000' ||
                   r2.topics[0] === methodSig('free(bytes32,uint128)') + '00000000000000000000000000000000000000000000000000000000' ||
                   r2.topics[0] === methodSig('draw(bytes32,uint128)') + '00000000000000000000000000000000000000000000000000000000' ||
                   r2.topics[0] === methodSig('wipe(bytes32,uint128)') + '00000000000000000000000000000000000000000000000000000000' ||
                   r2.topics[0] === methodSig('bite(bytes32)') + '00000000000000000000000000000000000000000000000000000000') {
          tub.cups.call(r2.topics[2], (e3, r3) => {
            if (!e3) {
              cupsQueue.place(() => Cup.collection.update({ cupi: web3.toBigNumber(r2.topics[2]).toNumber() },
                                    { $set:
                                            {
                                              art: r3[1].toNumber(),
                                              ink: r3[2].toNumber(),
                                              last_block: r2.blockNumber
                                            }
                                    }, {}, () => cupsQueue.next()));
            }
          });
        }
      }
    });
  });
}
