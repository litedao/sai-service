#! /usr/bin/env node

const mongoose = require('./schema').mongoose;
const settings = require('./settings');
const Web3 = require('web3');
var Queue = require('sync-queue');
const { exec } = require('child_process');

const web3 = new Web3();
let port = 8545;
process.argv.forEach(function (v, i) {
  if (v === '--port' && typeof process.argv[i + 1] !== 'undefined') {
    port = process.argv[i + 1];
  }
});
web3.setProvider(new Web3.providers.HttpProvider(`http://localhost:${port}`));

console.log(`MongoDB syncing from http://localhost:${port}`);

const topAbi = require('./abi/saitop').abi;
const tubAbi = require('./abi/saitub').abi;
const tapAbi = require('./abi/saitap').abi;
const voxAbi = require('./abi/saivox').abi;
const tokAbi = require('./abi/dstoken').abi;
const medAbi = require('./abi/medianizer').abi;

exec('git rev-parse --abbrev-ref HEAD', function(err, response, stderr) {
  const branch = response.trim().replace('.', '');
  web3.eth.getBlock(0, (e, res) => {
    let network = false;
    if (!e) {
      switch (res.hash) {
        case '0xa3c565fc15c7478862d50ccd6561e3c06b24cc509bf388941c25ea985ce32cb9':
          network = 'kovan';
          break;
        case '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3':
          network = 'main';
          break;
        default:
          network = 'private';
      }
      console.log(`${network} network detected`);
      console.log(`Using DB: sai-service-${network}-${branch}`);
      mongoose.connect(`mongodb://localhost/sai-service-${network}-${branch}`, { useMongoClient: true }, (e) => {
        if (!e) {
          init(network);
        }
      });
    }
  });
});

const methodSig = (method) => {
  return web3.sha3(method).substring(0, 10);
}

const getAddress = (object, name) => {
  const p = new Promise((resolve, reject) => {
    object[name].call((e, r) => {
      if (!e) {
        resolve(r);
      } else {
        reject(e);
      }
    });
  });
  return p;
}

const init = (network) => {
  const top = web3.eth.contract(topAbi).at(settings.chain[network].top);
  const promises = [getAddress(top, 'tub'), getAddress(top, 'tap'), getAddress(top, 'vox'), getAddress(top, 'gem'), getAddress(top, 'skr')];
  Promise.all(promises).then((r) => {
    if (r[0] && r[1] && r[2] && r[3] && r[4] && web3.isAddress(r[0]) && web3.isAddress(r[1]) && web3.isAddress(r[2]) && web3.isAddress(r[3]) && web3.isAddress(r[4])) {
      const tub = web3.eth.contract(tubAbi).at(r[0]);
      const tap = web3.eth.contract(tapAbi).at(r[1]);
      const vox = web3.eth.contract(voxAbi).at(r[2]);
      const gem = web3.eth.contract(tokAbi).at(r[3]);
      const skr = web3.eth.contract(tokAbi).at(r[4]);
      const promises = [getAddress(tub, 'pip'), getAddress(tub, 'pep')];
      Promise.resolve(promises).then((r2) => {
        if (r2[0] && web3.isAddress(r2[0]) && r2[1] && web3.isAddress(r2[1])) {
          const pip = web3.eth.contract(medAbi).at(r2[0]);
          const pep = web3.eth.contract(medAbi).at(r2[1]);
          executeSync(tub, tap, gem, skr, vox, pip, pep);
        }
      });
    }
  });
}

const executeSync = (tub, tap, gem, skr, vox, pip) => {
  const Var = mongoose.model('Var');
  const Way = mongoose.model('Way');
  const Mat = mongoose.model('Mat');
  const Per = mongoose.model('Per');
  const Pip = mongoose.model('Pip');
  const Cup = mongoose.model('Cup');
  const CupHistoryAction = mongoose.model('CupHistoryAction');

  Way.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      // 0x7761790000000000000000000000000000000000000000000000000000000000: 'way' in bytes32
      vox.LogNote({ sig: methodSig('mold(bytes32,uint256)'), foo: '0x7761790000000000000000000000000000000000000000000000000000000000' }, { fromBlock: (r.length === 0 ? 0 : parseInt(r[0].last_block, 10) + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Way.collection.insert({ value: web3.toBigNumber(r2.args.bar).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
            }
          });
        }
      });
    }
  });

  Mat.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      // 0x6d61740000000000000000000000000000000000000000000000000000000000: 'mat' in bytes32
      tub.LogNote({ sig: methodSig('mold(bytes32,uint256)'), foo: '0x6d61740000000000000000000000000000000000000000000000000000000000' }, { fromBlock: (r.length === 0 ? 0 : parseInt(r[0].last_block, 10) + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Mat.collection.insert({ value: web3.toBigNumber(r2.args.bar).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
              Var.collection.update({ name: 'mat' },
                                  {
                                    name: 'mat',
                                    value: web3.toBigNumber(r2.args.bar).div(1000000000).toNumber(),
                                  },
                                  { upsert: true });
            }
          });
        }
      });
    }
  });

  var persQueue = new Queue();
  Per.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      tap.LogNote({ sig: [methodSig('boom(uint256)'), methodSig('bust(uint256)')] }, { fromBlock: (r.length === 0 ? 0 : parseInt(r[0].last_block, 10) + 1) }, (e2, r2) => {
        if (!e2) {
          persQueue.place(() =>
            getPerValues(Per, tub, skr, gem, persQueue)
          );
        }
      });
    }
  });

  Pip.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      pip.LogValue({}, { fromBlock: (r.length === 0 ? 0 : parseInt(r[0].last_block, 10) + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Pip.collection.insert({ value: r2.args.val !== '0x' ? web3.toBigNumber(r2.args.val).toNumber() : null, last_block: r2.blockNumber, timestamp: r3.timestamp });
              Var.collection.update({ name: 'pip' },
                                {
                                  name: 'pip',
                                  value: web3.toBigNumber(r2.args.val).toNumber(),
                                },
                                { upsert: true });
            }
          });
        }
      });
    }
  });

  Pep.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      pep.LogValue({}, { fromBlock: (r.length === 0 ? 0 : parseInt(r[0].last_block, 10) + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Pep.collection.insert({ value: r2.args.val !== '0x' ? web3.toBigNumber(r2.args.val).toNumber() : null, last_block: r2.blockNumber, timestamp: r3.timestamp });
              Var.collection.update({ name: 'pep' },
                                {
                                  name: 'pep',
                                  value: web3.toBigNumber(r2.args.val).toNumber(),
                                },
                                { upsert: true });
            }
          });
        }
      });
    }
  });

  setInterval(() => {
    tub.chi.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'chi' },
                                {
                                  name: 'chi',
                                  value: r.div(1000000000).toNumber(),
                                },
                                { upsert: true });
      }
    });

    tub.rhi.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'rhi' },
                                {
                                  name: 'rhi',
                                  value: r.div(1000000000).toNumber(),
                                },
                                { upsert: true });
      }
    });

    vox.par.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'par' },
                                  {
                                    name: 'par',
                                    value: r.div(1000000000).toNumber(),
                                  },
                                  { upsert: true });
      }
    });

    // This is necessary temporarily for mainnet as there is not LogValue working
    pip.peek.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'pip' },
                                  {
                                    name: 'pip',
                                    value: r[1] ? web3.toBigNumber(r[0]).toNumber() : 0,
                                  },
                                  { upsert: true });
      }
    });

    tub.per((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'per' },
                        {
                          name: 'per',
                          value: web3.toBigNumber(r).div(1000000000).toNumber(),
                        },
                        { upsert: true });
      }
    });
  }, 5000);

  var cupsQueue = new Queue();
  Cup.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    web3.eth.filter({ fromBlock: (r.length === 0 ? 0 : r[0].last_block), address: tub.address }, (e2, r2) => {
      if (!e2) {
        cupsQueue.place(() =>
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              switch (r2.topics[0]) {
                case web3.sha3('LogNewCup(address,bytes32)'):
                  Cup.collection.update({ cupi: web3.toBigNumber(r2.data).toNumber() },
                                      {
                                        cupi: web3.toBigNumber(r2.data).toNumber(),
                                        lad: '0x' + r2.topics[1].substring(26),
                                        art: 0,
                                        ink: 0,
                                        closed: false,
                                        last_block: r2.blockNumber
                                      },
                                      { upsert: true }, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, 'open', web3.toBigNumber(r2.data).toNumber(), '0x' + r2.topics[1].substring(26), null, r2.blockNumber, r3.timestamp, r2.transactionHash));
                  break;
                case methodSig('shut(bytes32)') + '00000000000000000000000000000000000000000000000000000000':
                  Cup.collection.update({ cupi: web3.toBigNumber(r2.topics[2]).toNumber() },
                                      {
                                        $set:
                                              {
                                                art: 0,
                                                ink: 0,
                                                closed: true,
                                                last_block: r2.blockNumber
                                              }
                                      }, {}, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, 'shut', web3.toBigNumber(r2.topics[2]).toNumber(), '0x' + r2.topics[1].substring(26), null, r2.blockNumber, r3.timestamp, r2.transactionHash));
                  break;
                case methodSig('give(bytes32,address)') + '00000000000000000000000000000000000000000000000000000000':
                  Cup.collection.update({ cupi: web3.toBigNumber(r2.topics[2]).toNumber() },
                                      { $set:
                                              {
                                                lad: '0x' + r2.topics[3].substring(26),
                                                last_block: r2.blockNumber
                                              }
                                      }, {}, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, 'give', web3.toBigNumber(r2.topics[2]).toNumber(), '0x' + r2.topics[1].substring(26), '0x' + r2.topics[3].substring(26), r2.blockNumber, r3.timestamp, r2.transactionHash));
                  break;
                default:
                  const methods = ['lock(bytes32,uint256)', 'free(bytes32,uint256)', 'draw(bytes32,uint256)', 'wipe(bytes32,uint256)', 'bite(bytes32)'];
                  let action = null;
                  let cupi = null;
                  let param = null;
                  methods.forEach(value => {
                    if (r2.topics[0] === methodSig(value) + '00000000000000000000000000000000000000000000000000000000') {
                      action = value.substring(0, 4);
                      cupi = web3.toBigNumber(r2.topics[2]).toNumber();
                      param = action === 'bite' ? null : web3.toBigNumber('0x' + r2.topics[3].substring(26)).toNumber();
                      tub.cups.call(r2.topics[2], (e4, r4) => {
                        if (!e4) {
                          Cup.collection.update({ cupi },
                                                { $set:
                                                        {
                                                          art: r4[1].toNumber(),
                                                          ink: r4[2].toNumber(),
                                                          last_block: r2.blockNumber
                                                        }
                                                }, {}, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, action, cupi, '0x' + r2.topics[1].substring(26), param, r2.blockNumber, r3.timestamp, r2.transactionHash));
                        }
                      });
                    }
                  });
                  if (!action) {
                    cupsQueue.next();
                  }
                  break;
              }
            }
          })
        );
      }
    });
  });
}

const insertCupHistoryAction = (CupHistoryAction, cupsQueue, action, cupi, sender, param, block, timestamp, transactionHash) => {
  CupHistoryAction.collection.update(
                                      { transactionHash },
                                      {
                                        action,
                                        cupi,
                                        sender,
                                        param,
                                        block,
                                        timestamp,
                                        transactionHash
                                      },
                                      { upsert: true },
                                      () => cupsQueue.next()
                                    );
}

const getPerValues = (Per, tub, skr, gem, persQueue) => {
  Per.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      const fromBlock = (r.length === 0 ? 0 : parseInt(r[0].last_block, 10) + 1);
      const promises = [getLogs(skr, 'LogNote', { sig: [methodSig('mint(uint256)'), methodSig('burn(uint256)')] }, fromBlock),
                        getLogs(gem, 'Transfer', { from: tub.address }, fromBlock),
                        getLogs(gem, 'Transfer', { to: tub.address }, fromBlock)];

      const perResults = {};
      Promise.all(promises).then((r2) => {
        if (r2[0] && r2[1] && r2[2]) {
          r2[0].forEach(value => {
            if (typeof perResults[value.blockNumber] === 'undefined') {
              perResults[value.blockNumber] = { skr : { amount: 0, add: {}, del: {} }, gem : { amount: 0, add: {}, del: {} }  }
            }
            perResults[value.blockNumber].skr[value.args.sig === methodSig('mint(uint256)') ? 'add' : 'del'] = value;
          });
          r2[1].forEach(value => {
            if (typeof perResults[value.blockNumber] === 'undefined') {
              perResults[value.blockNumber] = { skr : { amount: 0, add: {}, del: {} }, gem : { amount: 0, add: {}, del: {} }  }
            }
            perResults[value.blockNumber].gem.del = value;
          });
          r2[2].forEach(value => {
            if (typeof perResults[value.blockNumber] === 'undefined') {
              perResults[value.blockNumber] = { skr : { amount: 0, add: {}, del: {} }, gem : { amount: 0, add: {}, del: {} }  }
            }
            perResults[value.blockNumber].gem.add = value;
          });
          let skrBigNum = web3.toBigNumber(r.length === 0 ? 0 : r[0].totSkr);
          let gemBigNum = web3.toBigNumber(r.length === 0 ? 0 : r[0].tubGem);
          const promisesInsert = [];
          Object.keys(perResults).map(key => {
            const value = perResults[key];
            skrBigNum = skrBigNum.add(typeof value.skr.add.args !== 'undefined' ? web3.toBigNumber(value.skr.add.args.foo) : 0);
            skrBigNum = skrBigNum.minus(typeof value.skr.del.args !== 'undefined' ? web3.toBigNumber(value.skr.del.args.foo) : 0);
            gemBigNum = gemBigNum.add(typeof value.gem.add.args !== 'undefined' ? value.gem.add.args.value : 0);
            gemBigNum = gemBigNum.minus(typeof value.gem.del.args !== 'undefined' ? value.gem.del.args.value : 0);
            const per = gemBigNum.div(skrBigNum).times(web3.toBigNumber(10).pow(18)).toNumber();
            const totSkr = skrBigNum.valueOf();
            const tubGem = gemBigNum.valueOf();
            promisesInsert.push(insertPer(Per, per, key, totSkr, tubGem));
          });
          Promise.all(promisesInsert).then(() => {
            persQueue.next();
          });
        } else {
          persQueue.next();
        }
      });
    } else {
      persQueue.next();
    }
  });
}

const insertPer = (Per, value, blockNumber, totSkr, tubGem) => {
  return new Promise((resolve, reject) => {
    web3.eth.getBlock(blockNumber, (e, r) => {
      if (!e) {
        Per.collection.insert({ value, last_block: blockNumber, timestamp: r.timestamp, totSkr, tubGem }, () => {
          resolve(r);
        });
      } else {
        reject(e);
      }
    });
  });
}

const getLogs = (obj, event, conditions, fromBlock) => {
  return new Promise((resolve, reject) => {
    const results = {};
    obj[event](conditions, { fromBlock }).get((e, r) => {
      if (!e) {
        resolve(r);
      } else {
        reject(e);
      }
    });
  });
}
