#! /usr/bin/env node

const mongoose = require('./schema').mongoose;
const settings = require('./settings');
const Web3 = require('web3');
var Queue = require('sync-queue');

const web3 = new Web3();
let port = 8545;
process.argv.forEach(function (v, i) {
  if (v === '--port' && typeof process.argv[i + 1] !== 'undefined') {
    port = process.argv[i + 1];
  }
});
web3.setProvider(new Web3.providers.HttpProvider(`http://localhost:${port}`));

console.log(`MongoDB syncing from http://localhost:${port}`);

const topAbi = require('./abi/top').abi;
const tubAbi = require('./abi/tub').abi;
const tapAbi = require('./abi/tap').abi;
const jarAbi = require('./abi/jar').abi;
const tipAbi = require('./abi/tip').abi;
const medAbi = require('./abi/medianizer').abi;

web3.eth.getBlock(0, (e, res) => {
  let network = false;
  if (!e) {
    switch (res.hash) {
      case '0xa3c565fc15c7478862d50ccd6561e3c06b24cc509bf388941c25ea985ce32cb9':
        network = 'kovan';
        break;
      case '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3':
        network = 'main';
        break;
      default:
        network = 'private';
    }
    console.log(`${network} network detected`)
    mongoose.connect(`mongodb://localhost/sai-service-${network}`, { useMongoClient: true }, (e) => {
      if (!e) {
        init(network);
      }
    });
  }
 });

const methodSig = (method) => {
  return web3.sha3(method).substring(0, 10)
}

const getAddress = (object, name) => {
  const p = new Promise((resolve, reject) => {
    object[name].call((e, r) => {
      if (!e) {
        resolve(r);
      } else {
        reject(e);
      }
    });
  });
  return p;
}

const init = (network) => {
  const top = web3.eth.contract(topAbi).at(settings.chain[network].top);
  const promises = [getAddress(top, 'tub'), getAddress(top, 'tap')];
  Promise.all(promises).then((r) => {
    if (r[0] && r[1] && web3.isAddress(r[0]) && web3.isAddress(r[1])) {
      const tub = web3.eth.contract(tubAbi).at(r[0]);
      const tap = web3.eth.contract(tapAbi).at(r[1]);
      const promises2 = [getAddress(tub, 'jar'), getAddress(tub, 'tip')];
      Promise.all(promises2).then((r2) => {
        if (r2[0] && r2[1] && web3.isAddress(r2[0]) && web3.isAddress(r2[1])) {
          const jar = web3.eth.contract(jarAbi).at(r2[0]);
          const tip = web3.eth.contract(tipAbi).at(r2[1]);
          const promise = getAddress(jar, 'pip');
          Promise.resolve(promise).then((r3) => {
            if (r3 && web3.isAddress(r3)) {
              const med = web3.eth.contract(medAbi).at(r3);
              executeSync(tub, tap, jar, tip, med);
            }
          });
        }
      });
    }
  });
}

const executeSync = (tub, tap, jar, tip, med) => {
  const Var = mongoose.model('Var');
  const Way = mongoose.model('Way');
  const Mat = mongoose.model('Mat');
  const Per = mongoose.model('Per');
  const Pip = mongoose.model('Pip');
  const Cup = mongoose.model('Cup');
  const CupHistoryAction = mongoose.model('CupHistoryAction');

  Way.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      tip.LogNote({ sig: methodSig('coax(uint128)') }, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Way.collection.insert({ value: web3.toBigNumber(r2.args.foo).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
            }
          });
        }
      });
    }
  });

  Mat.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      tub.LogNote({ sig: methodSig('cuff(uint128)') }, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Mat.collection.insert({ value: web3.toBigNumber(r2.args.foo).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
              Var.collection.update({ name: 'mat' },
                                  {
                                    name: 'mat',
                                    value: web3.toBigNumber(r2.args.foo).div(1000000000).toNumber(),
                                  },
                                  { upsert: true });
            }
          });
        }
      });
    }
  });

  Per.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      tap.LogNote({ sig: [methodSig('boom(uint128)'), methodSig('bust(uint128)')] }, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              jar.per(r2.blockNumber, (e4, r4) => {
                if (!e4) {
                  Per.collection.insert({ value: web3.toBigNumber(r4).toNumber(), last_block: r2.blockNumber, timestamp: r3.timestamp });
                  Var.collection.update({ name: 'per' },
                                  {
                                    name: 'per',
                                    value: web3.toBigNumber(r4).div(1000000000).toNumber(),
                                  },
                                  { upsert: true });
                }
              });
            }
          });
        }
      });
    }
  });

  Pip.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    if (!e) {
      med.LogValue({}, { fromBlock: (r.length === 0 ? 0 : r[0].last_block + 1) }, (e2, r2) => {
        if (!e2) {
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              Pip.collection.insert({ value: r2.args.val !== '0x' ? web3.toBigNumber(r2.args.val).toNumber() : null, last_block: r2.blockNumber, timestamp: r3.timestamp });
              Var.collection.update({ name: 'pip' },
                                {
                                  name: 'pip',
                                  value: web3.toBigNumber(r2.args.val).toNumber(),
                                },
                                { upsert: true });
            }
          });
        }
      });
    }
  });

  setInterval(() => {
    tub.chi.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'chi' },
                                {
                                  name: 'chi',
                                  value: r.div(1000000000).toNumber(),
                                },
                                { upsert: true });
      }
    });

    tip.par.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'par' },
                                  {
                                    name: 'par',
                                    value: r.toNumber(),
                                  },
                                  { upsert: true });
      }
    });

    // This is necessary temporarily for mainnet as there is not LogValue Log working
    med.peek.call((e, r) => {
      if (!e) {
        Var.collection.update({ name: 'pip' },
                                  {
                                    name: 'pip',
                                    value: r[0] ? web3.toBigNumber(r[1]).toNumber() : 0,
                                  },
                                  { upsert: true });
      }
    });
  }, 5000);

  var cupsQueue = new Queue();
  Cup.collection.find().sort({ 'last_block': -1 }).limit(1).toArray((e, r) => {
    web3.eth.filter({ fromBlock: (r.length === 0 ? 0 : r[0].last_block), address: tub.address }, (e2, r2) => {
      if (!e2) {
        cupsQueue.place(() =>
          web3.eth.getBlock(r2.blockNumber, (e3, r3) => {
            if (!e3) {
              switch (r2.topics[0]) {
                case web3.sha3('LogNewCup(address,bytes32)'):
                  Cup.collection.update({ cupi: web3.toBigNumber(r2.data).toNumber() },
                                      {
                                        cupi: web3.toBigNumber(r2.data).toNumber(),
                                        lad: '0x' + r2.topics[1].substring(26),
                                        art: 0,
                                        ink: 0,
                                        closed: false,
                                        last_block: r2.blockNumber
                                      },
                                      { upsert: true }, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, 'open', web3.toBigNumber(r2.data).toNumber(), '0x' + r2.topics[1].substring(26), null, r2.blockNumber, r3.timestamp, r2.transactionHash));
                  break;
                case methodSig('shut(bytes32)') + '00000000000000000000000000000000000000000000000000000000':
                  Cup.collection.update({ cupi: web3.toBigNumber(r2.topics[2]).toNumber() },
                                      {
                                        $set:
                                              {
                                                art: 0,
                                                ink: 0,
                                                closed: true,
                                                last_block: r2.blockNumber
                                              }
                                      }, {}, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, 'shut', web3.toBigNumber(r2.topics[2]).toNumber(), '0x' + r2.topics[1].substring(26), null, r2.blockNumber, r3.timestamp, r2.transactionHash));
                  break;
                case methodSig('give(bytes32,address)') + '00000000000000000000000000000000000000000000000000000000':
                  Cup.collection.update({ cupi: web3.toBigNumber(r2.topics[2]).toNumber() },
                                      { $set:
                                              {
                                                lad: '0x' + r2.topics[3].substring(26),
                                                last_block: r2.blockNumber
                                              }
                                      }, {}, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, 'give', web3.toBigNumber(r2.topics[2]).toNumber(), '0x' + r2.topics[1].substring(26), '0x' + r2.topics[3].substring(26), r2.blockNumber, r3.timestamp, r2.transactionHash));
                  break;
                default:
                  const methods = ['lock(bytes32,uint128)', 'free(bytes32,uint128)', 'draw(bytes32,uint128)', 'wipe(bytes32,uint128)', 'bite(bytes32)'];
                  let action = null;
                  let cupi = null;
                  let param = null;
                  methods.forEach(value => {
                    if (r2.topics[0] === methodSig(value) + '00000000000000000000000000000000000000000000000000000000') {
                      action = value.substring(0, 4);
                      cupi = web3.toBigNumber(r2.topics[2]).toNumber();
                      param = action === 'bite' ? null : web3.toBigNumber('0x' + r2.topics[3].substring(26)).toNumber();
                      tub.cups.call(r2.topics[2], (e4, r4) => {
                        if (!e4) {
                          Cup.collection.update({ cupi },
                                                { $set:
                                                        {
                                                          art: r4[1].toNumber(),
                                                          ink: r4[2].toNumber(),
                                                          last_block: r2.blockNumber
                                                        }
                                                }, {}, () => insertCupHistoryAction(CupHistoryAction, cupsQueue, action, cupi, '0x' + r2.topics[1].substring(26), param, r2.blockNumber, r3.timestamp, r2.transactionHash));
                        }
                      });
                    }
                  });
                  if (!action) {
                    cupsQueue.next();
                  }
                  break;
              }
            }
          })
        );
      }
    });
  });
}

const insertCupHistoryAction = (CupHistoryAction, cupsQueue, action, cupi, sender, param, block, timestamp, transactionHash) => {
  CupHistoryAction.collection.update(
                                      { transactionHash },
                                      {
                                        action,
                                        cupi,
                                        sender,
                                        param,
                                        block,
                                        timestamp,
                                        transactionHash
                                      },
                                      { upsert: true },
                                      () => cupsQueue.next()
                                    );
}
